\chapter{Testy}
\label{cha:testy}

W niniejszym rozdziale przedstawiono proces testowania oraz ich wyniki. Obszarem zainteresowań jest poprawność zaimplementowanego algorytmu oraz porównanie szybkości działania z~innymi implementacjami.

Do porównań opracowano dwie dodatkowe implementacje algorytmu zrealizowane z użyciem biblioteki OpenCV: jedna przeprowadza obliczenia na procesorze (CPU), druga przeprowadza obliczenia na karcie graficznej (GPU) z~wykorzystaniem pakietu CUDA.

\section{Testowanie poprawności}
\label{sec:testPoprawnosc}

Celem tej części testowania było sprawdzenie czy zrealizowane implementacje działają w~ten sam sposób. Proces testowania był następujący:

\begin{enumerate}
\item Przetworzenie tego samego obrazu za pomocą wszystkich implementacji. Wybrany obraz był reprezentowany w~kilku skalach. Przeprowadzono obliczenia dla każdej rozpoznawanej cechy.
\item Zestawienie obrazów wynikowych z~podziałem na cechy oraz skalę. Dla każdej cechy i~skali otrzymano trzy obrazy, po jednym dla każdej implementacji.
\item Porównanie wyników. Idealnym wynikiem byłoby otrzymanie trzech identycznych obrazów wynikowych. W praktyce jest to mało prawdopodobne, z~uwagi na różnice podczas zaokrąglenia obliczeń w~implementacjach.
\end{enumerate}

Dla każdej rozpoznawanej cechy oraz dla samego wyznaczania reprezentacji skali wybrano pięć obrazów. Obliczenia przeprowadzono dla dziesięciu skal przy kroku cztery. Spośród otrzymanych obrazów wybrano dwa najbardziej interesujące (dla każdej cechy i~dla reprezentacji skali) i~zaprezentowano w~części \ref{subsec:prezentacjaObrazowRoznicowych}.

Wszystkie obrazy wyjściowe zostały wykorzystane do analizy poprawności implementacji. W celu porównania wszystkich implementacji opracowano dwa współczynniki przedstawione we wzorach: \ref{eq:procentZlychPikseli} i~\ref{eq:sredniaOdchylenia}. Wyniki oraz ich omówienie zaprezentowano w~części \ref{subsec:porownanieNumerycznePoprawnosc}.

\begin{equation}
\label{eq:procentZlychPikseli}
p_{XY} = \frac{\sum_{i}^{N}|sgn(X_{ij}-Y_{ij})	|}{N}
\end{equation}
gdzie:

$ p_{XY} $ - współczynnik ilości różnych pikseli,

$ X, Y $ - obrazy, dla których wyznaczany jest współczynnik,

$ N $ - liczba pikseli w~obrazie,

$ sgn $ - funkcja signum \cite{Signum}.

\begin{equation}
\label{eq:sredniaOdchylenia}
v_{XY} = \frac{\sum_{i}^{N}|X_{ij}-Y_{ij}|}{\sum_{i}^{N}|sgn(X_{ij}-Y_{ij})|}
\end{equation}
gdzie:

$ v_{XY} $ - współczynnik wielkości średniego odchylenia,

$ X, Y $ - obrazy, dla których wyznaczany jest współczynnik,

$ N $ - liczba pikseli w~obrazie,

$ sgn $ - funkcja signum \cite{Signum}.

Współczynnik ilości różnych pikseli pokazuje ile różnych pikseli, w~stosunku do całego obrazu, jest obecnych dla dwóch różnych implementacji. Współczynnik wielkości średniego odchylenia jest wykorzystywany tylko dla obrazów reprezentacji skali, ponieważ obrazy wyjściowe dla wyznaczania cech są binarne. Współczynnik są wyliczane dla jednego obrazu w~jednej skali dla wszystkich trzech implementacji (porównywany jest wynik każdej implementacji z~każdą).

\subsection{Prezentacja różnic w~obrazach wyjściowych}
\label{subsec:prezentacjaObrazowRoznicowych}

Poniżej przedstawiono wyniki porównań pomiędzy obrazami otrzymanymi za pomocą różnych implementacji. Przedstawione są tutaj jedynie dwa wybrane obrazy wejściowe wybrane spośród pięciu, dla każdej rozpoznawanej cechy oraz dla reprezentacji skali. Obrazy różnicowe są otoczone ramką w~celu zwiększenia czytelności.

\subsubsection{Reprezentacja skali}
\label{subsubsec:reprezentacjaSkaliRysunki}

Obrazy wejściowe przedstawione są na rys. \ref{fig:valPure02} i \ref{fig:valPure03}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_pure_02.png}
\end{center}
\caption{Pierwszy obraz wejśćiowy dla reprezentacji skali}
\label{fig:valPure02}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_pure_03.png}
\end{center}
\caption{Drugi obraz wejśćiowy dla reprezentacji skali}
\label{fig:valPure03}
\end{figure}

Obrazy różnicowe są przedstawione na rys. \ref{fig:valPure2} i~\ref{fig:valPure3}. 

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CL-CVCPU_02_09.png}}
	\caption{Porównanie implementacji CL i CVCPU dla reprezentacji skali}
	\label{fig:valPure2CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CL-CVGPU_02_09.png}}
	\caption{Porównanie implementacji CL i CVGPU dla reprezentacji skali}
	\label{fig:valPure2CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CVCPU-CVCPU_02_09.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla reprezentacji skali}
	\label{fig:valPure2CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe reprezentacji skali dla pierwszego pliku wejściowego}
\label{lena_scales}
\label{fig:valPure2}
\end{figure}

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CL-CVCPU_03_09.png}}
	\caption{Porównanie implementacji CL i CVCPU dla reprezentacji skali}
	\label{fig:valPure3CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CL-CVGPU_03_09.png}}
	\caption{Porównanie implementacji CL i CVGPU dla reprezentacji skali}
	\label{fig:valPure3CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_pure_CVCPU-CVCPU_03_09.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla reprezentacji skali}
	\label{fig:valPure3CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe reprezentacji skali dla drugiego pliku wejściowego}
\label{lena_scales}
\label{fig:valPure3}
\end{figure}

Na podstawie obrazów różnicowych można stwierdzić, że główne rozbieżności pomiędzy implementacjami występują głównie na krawędziach. Ponadto różnice są niewielkie. Maksymalna wartość odchylenia nie przekracza $ 0,3\% $ maksymalnej wartości piksela. Rozbieżności pomiędzy implementacjami są sposodowane błędami związanymi z~ograniczaniemi systemów obliczeniowych (m. in. błąd zaokrąglenia). Istotne obiekty, które mają być rozpoznane znajdują się w~środku obrazu, nie w~bezpośrednim sąsiedztwie krawędzi, dlatego różnice na brzegu obrazu nie są istotne dla dalszego przetwarzania. W centrum obrazu widać także niewielkie różne, lecz są one niewielkie (podobnie, nie przekraczają $ 0,3\% $ maksymalnej wartości piksela). Widać je zwłaszcza na obrazach \ref{fig:valPure3CLCVCPU} i~\ref{fig:valPure3CLCVCPU}. Można też zauważyć, że różnice występują pojedynczo, nie są zgrupowane.

Implementacje wykonane w~OpenCV dla liczenia reprezentacji skali dają identyczne wyniki, co można zauważyć na obrazach \ref{fig:valPure2CVCPUCVGPU} i~\ref{fig:valPure3CVCPUCVGPU}.

\subsubsection{Plamy}
\label{subsubsec:plamyRysunki}

Obrazy wejściowe przedstawione są na rys. \ref{fig:valBlob01} i \ref{fig:valBlob02}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_blob_01.png}
\end{center}
\caption{Pierwszy obraz wejśćiowy dla rozpoznawania plam}
\label{fig:valBlob01}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_blob_02.png}
\end{center}
\caption{Drugi obraz wejśćiowy dla rozpoznawania plam}
\label{fig:valBlob02}
\end{figure}

Obrazy różnicowe są przedstawione na rys. \ref{fig:valBlob1} i~\ref{fig:valBlob2}. 

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CL-CVCPU_01_09.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania plam}
	\label{fig:valBlob2CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CL-CVGPU_01_09.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania plam}
	\label{fig:valBlob2CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CVCPU-CVCPU_01_09.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania plam}
	\label{fig:valblob2CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania plam dla pierwszego pliku wejściowego}
\label{lena_scales}
\label{fig:valBlob1}
\end{figure}

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CL-CVCPU_02_09.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania plam}
	\label{fig:valBlob3CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CL-CVGPU_02_09.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania plam}
	\label{fig:valBlob3CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_blob_CVCPU-CVCPU_02_09.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania plam}
	\label{fig:valBlob3CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania plam dla drugiego pliku wejściowego}
\label{lena_scales}
\label{fig:valBlob2}
\end{figure}

Z~przedstawionych obrazów wynika, że podczas rozpoznawania plam najwięcej różnic powstaje w~okolicach krawędzi. Jest to dobrze widoczne na obrazach \ref{fig:valBlob2CLCVCPU} i~\ref{fig:valBlob2CLCVCPU}. Porównując do wyników testów dla reprezentacji skali można wywnioskować że te różnice są sposodowane różnicami powstałymi podczas filtracji Gaussa.

Na rys. \ref{fig:valBlob2} widać również różnice w~środku obrazu. Różnice te są sposodowane błędami związanymi z~ograniczaniemi systemów obliczeniowych (m. in. błąd zaokrąglenia). Ilość różnych pikseli nie jest duża, lecz większa niż w~przypadku innych rozpoznawanych cech.


\subsubsection{Krawędzie}
\label{subsubsec:krawedzieRysunki}

Obrazy wejściowe przedstawione są na rys. \ref{fig:valEdge00} i \ref{fig:valEdge02}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_edge_00.png}
\end{center}
\caption{Pierwszy obraz wejśćiowy dla rozpoznawania krawędzi}
\label{fig:valEdge00}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_edge_02.png}
\end{center}
\caption{Drugi obraz wejśćiowy dla rozpoznawania krawędzi}
\label{fig:valEdge02}
\end{figure}

Obrazy różnicowe są przedstawione na rys. \ref{fig:valEdge0} i~\ref{fig:valEdge2}. 

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CL-CVCPU_00_00.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania krawędzi}
	\label{fig:valEdge0CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CL-CVGPU_00_00.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania krawędzi}
	\label{fig:valEdge0CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CVCPU-CVCPU_00_00.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania krawędzi}
	\label{fig:valEdge0CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania krawędzi dla pierwszego pliku wejściowego}
\label{lena_scales}
\label{fig:valEdge0}
\end{figure}

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CL-CVCPU_02_03.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania krawędzi}
	\label{fig:valEdge2CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CL-CVGPU_02_03.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania krawędzi}
	\label{fig:valEdge2CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_edge_CVCPU-CVCPU_02_03.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania krawędzi}
	\label{fig:valEdge2CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania krawędzi dla drugiego pliku wejściowego}
\label{lena_scales}
\label{fig:valEdge2}
\end{figure}

Na obrazach różnicowych powstałych poczas rozpoznawania krawędzi można zauważyć, że licza różnych pikseli jest niewielka. Zdecydowana większość tych pikseli znajduje się na krawędziach. Jest to spowodowane różnicami powstałymi na etapie tworzenia reprezentacji skali. W~środku obrazu również można zauważyć różnice, lecz jest ich niewielka liczba.

\subsubsection{Narożniki}
\label{subsubsec:naroznikiRysunki}

Obrazy wejściowe przedstawione są na rys. \ref{fig:valCorner01} i \ref{fig:valCorner02}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_corner_01.png}
\end{center}
\caption{Pierwszy obraz wejśćiowy dla rozpoznawania narożników}
\label{fig:valCorner01}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_corner_02.png}
\end{center}
\caption{Drugi obraz wejśćiowy dla rozpoznawania narożników}
\label{fig:valCorner02}
\end{figure}

Obrazy różnicowe są przedstawione na rys. \ref{fig:valCorner1} i~\ref{fig:valCorner2}. 

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CL-CVCPU_01_07.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania narożników}
	\label{fig:valCorner1CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CL-CVGPU_01_07.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania narożników}
	\label{fig:valCorner1CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CVCPU-CVCPU_01_07.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania narożników}
	\label{fig:valCorner1CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania narożników dla pierwszego pliku wejściowego}
\label{lena_scales}
\label{fig:valCorner1}
\end{figure}

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CL-CVCPU_02_06.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania narożników}
	\label{fig:valCorner2CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CL-CVGPU_02_06.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania narożników}
	\label{fig:valCorner2CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_corner_CVCPU-CVCPU_02_06.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania narożników}
	\label{fig:valCorner2CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania narożników dla drugiego pliku wejściowego}
\label{lena_scales}
\label{fig:valCorner2}
\end{figure}

Na obrazach różnicowych można zauważyć pojedyncze różnice. Jest to też efektem tego, że liczba wykrywanych narożników na przedstawionych obrazach w~wybranej skali nie jest duża. Mniejsza ilość wykrytych obiektów powoduje, że liczba błędów jest mniejsza.

Na rys. \ref{fig:valCorner2} nie widać żadnych różnic.

\subsubsection{Granie}
\label{subsubsec:granieRysunki}

Obrazy wejściowe przedstawione są na rys. \ref{fig:valRidge01} i~\ref{fig:valRidge04}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_ridge_01.png}
\end{center}
\caption{Pierwszy obraz wejśćiowy dla rozpoznawania grani}
\label{fig:valRidge01}
\end{figure}

\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{TestyPoprawnosci/in_ridge_04.png}
\end{center}
\caption{Drugi obraz wejśćiowy dla rozpoznawania grani}
\label{fig:valRidge04}
\end{figure}

Obrazy różnicowe są przedstawione na rys. \ref{fig:valRidge1} i~\ref{fig:valRidge4}. 

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CL-CVCPU_01_01.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania grani}
	\label{fig:valRidge1CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CL-CVGPU_01_01.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania grani}
	\label{fig:valRidge1CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CVCPU-CVCPU_01_01.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania grani}
	\label{fig:valRidge1CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania grani dla pierwszego pliku wejściowego}
\label{lena_scales}
\label{fig:valRidge1}
\end{figure}

\begin{figure}
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CL-CVCPU_04_04.png}}
	\caption{Porównanie implementacji CL i CVCPU dla rozpoznawania grani}
	\label{fig:valRidge4CLCVCPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CL-CVGPU_04_04.png}}
	\caption{Porównanie implementacji CL i CVGPU dla rozpoznawania grani}
	\label{fig:valRidge4CLCVGPU}
\end{subfigure}
~
\begin{subfigure}[t]{0.3\textwidth}
	\centering
	\setlength\fboxsep{0pt}
	\setlength\fboxrule{0.5pt}
	\fbox{\includegraphics[width=\textwidth]{TestyPoprawnosci/diff_ridge_CVCPU-CVCPU_04_04.png}}
	\caption{Porównanie implementacji CVCPU i CVGPU dla rozpoznawania grani}
	\label{fig:valRidge4CVCPUCVGPU}                 
\end{subfigure}
\caption{Obrazy różnicowe rozpoznawania grani dla drugiego pliku wejściowego}
\label{lena_scales}
\label{fig:valRidge4}
\end{figure}

Na obrazach różnicowych można zauważyć, że na krawędziach powstało bardzo dużo różnic. Są one pochodną rozbieżności powstałych na etapie tworzenia reprezentacji skali. W~środku obrazu widać tylko pojedyncze różnice. 

\subsection{Porównanie wszystkich obrazów}
\label{subsec:porownanieNumerycznePoprawnosc}

Poniżej przedstawiono numeryczne porównanie obrazów otrzymanych z~użyciem trzech implementacji. Wykorzystano do tego celu współczynniki przedstawione na równaniach \ref{eq:procentZlychPikseli}~i~\ref{eq:sredniaOdchylenia}.

\begin{table}
\caption{cos}
\label{tab:cos}
\begin{tabular}{|c|c|c|}
\hline
0,0027897 & 0,0027812 & 4,4179e-05 \\ \hline
0,003062 & 0,003046 & 4,1661e-05 \\ \hline
0,002602 & 0,002684 & 0,00011341 \\ \hline
0,0022778 & 0,0023323 & 7,9742e-05 \\ \hline
0,002077 & 0,0021068 & 4,9272e-05 \\ \hline
0,0023807 & 0,0023871 & 5,4858e-05 \\ \hline
0,0020579 & 0,0020779 & 6,3091e-05 \\ \hline
0,0019524 & 0,0019555 & 5,4328e-05 \\ \hline
0,0022939 & 0,0022904 & 5,1616e-05 \\ \hline
0,0023304 & 0,002334 & 6,8522e-05 \\ \hline

\end{tabular}
\end{table}
% tabele

\section{Testowanie szybkości działania}
\label{sec:testSzybkosc1}

Testowanie szybkości działania oparto na porównaniu szybkości działania wszystkich implementacji algorytmu Scale Space. Liczony był czas działania algorytmu. Im krótszy czas tym lepsza implementacja algorytmu Scale Space.

Mierzeniu podlagał czas trwania następujących czynności:
\begin{itemize}
\item czas wyzaczania reprezentacji Scale Space,
\item czas wkrywania cech na obrazach (wraz z~wcześniejszym wyznaczeniem reprezentacji Scale Space) - osobno dla każdej cechy.
\end{itemize}

Do testów użyto różnych kart graficznych.
\begin{enumerate}
\item GeForce GT 555M \cite{GT555M} o następujących parametrach:
\begin{itemize}
\item libcza rdzeni: 144,
\item zegar układu graficznego: 675 MHz,
\item zegar procesora: 1350 MHz,
\item częstotliwość danych pamięci: 1800 MHz,
\item interfejs pamięci: 128-bitowy,
\item szerokość pasma pamięci: 28,80GB/s,
\item dostępna pamięć: 4095 MB.
\end{itemize}
\item druga karta z laboratorium.
\end{enumerate}

%opis maszyn, na których były wykonane testy

\section{Podsumowanie testów}
\label{sec:testPodsumowanie}

%podsumowanie testów
