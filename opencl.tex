\chapter{OpenCL}
\label{cha:opencl}

W~tym rodziale przedstawiono sposób implementacji algorytmów z~użyciem standardu OpenCL oraz stworzoną bibliotekę służącą ułatwieniu pracy. Zdecydowano się na realizację danej biblioteki z~uwagi na to, że w~cześci programu, która kontroluje wykonanie kodu na karcie graficznej (nazywanego kernelami) wiele czynności jest powtarzanych przy implementacji każdego algorytmu. Zatem zadaniem biblioteki jest ułatwienie implementacji kontrolera nie ograniczając możliwości oferowanych przez standard OpenCL oraz umożliwienie łatwiego rozszerzania dostępnych funkji.

\section{Implementacja algorytmów z~użyciem OpenCL}  
\label{sec:szczegolyOpenCL}

W celu implementacji algorytmów z~użyciem standardu OpenCL konieczne jest napisanie dwóch oddzielnych części. Pierwszą jest kod algorytmu zapisany w~języku stworzonym w ramach standardu OpenCL, drugą jest kod wykonywany na procesorze ogólnego przeznaczania wykorzystujący API, które jest zdefiniowane w języku C.

Algorytmy implementowane są w~postaci funkcji, które są nazywane kernelami. Są one napisane w~języku stworzonym przez twórców standardu. Bazuje on na języku ISO C99 i~zawiera jego podzbiór wraz z~rozszerzeniami służacymi implementacji algorytmów w sposób równoległy, ułatwiającymi obsługę wektorów, macierzy oraz obrazów. Kompilacja kodu napisanego w~tym języku odbywa się w~trakcie działania programu kontrolera, ponieważ sposób kompilacji jest zależny od posiadanego urządzenia, na którym będzie wykonywany kod. Jest to spowodowane tym, że kod języka OpenCL jest kompilowany zależnie od platformy, na której jest uruchamiany. Może to powodować problemy z~przenoszalnością pomiędzy różnymi urządzeniami w~przypadku, gdy używane są rozszerzenia OpenCL. W~celu uniknięcia problemów należy stosować konstrukcje języka, które są częścią podstawowej wersji standardu. Ta część jest wystarczająca do większości algorytmów.

Zadania kodu kontrolera można podzielić na dwa fragmenty. Pierwszym, jest inicjalizacja, podczas której jest dokonywany wybór urządzenia docelowaego oraz kompilacja kerneli. Proces wyboru urządzenia może być bardziej skomplikony w przypadku, gdy w~systemie jest dostępnych więcej niż jedna platforma OpenCL. Przykładem takiej sytuacji jest posiadanie dwóch kart graficznych w~jednym komputerze. W~zależności od parametrów urządzeniem może być porządane użycie jednej, lepszej karty lub obu. OpenCL pozwala na wykorzystanie obu rozwiązań. Dzięki temu, że kod kerneli może być wykonywany asynchronicznie można przeprowadzać obliczenia jednocześnie na wielu urządzeniach. Po wyborze platformy docelowej należy skompilować kernel. Dopisać o kompilacji!!!!!!!!!!!!!

Drugim fragmentem kodu kontrolera jest przekazywanie parametrów, wykonywanie kerneli oraz pobieranie wyników. Te czynności są realizwane przy każdym nowy algorytmie.

DOPISA!

\section{Zrealizowana biblioteka}  
\label{sec:biblioteka}

Biblioteka zastała zaimplementowana w języku C++. Wybrano ten język ponieważ jego integracja z~API OpenCL napisanym w języku C jest prosta. Biblioteka została zrealizowana w~sposób obiektowy oraz z~użyciem wyjątków ułatwiających pracę. Więcej szczegółów dotyczącyh wyjątków jest przedstawiona w~sekcji \ref{subsec:obslugabledow}. Obiektowość pozwala na ograniczenie redundancji napisanego kodu odpowiedzialnego za kompilację, przekazywanie argumentów, wykonywanie kernel oraz pobieranie wyników. Aby to umożliwić należy opracować zbiór reguł, których należy przestrzegać podczas pisania kerneli. Są one opisane w sekcji \ref{subsec:regulykerneli}. Reguły te nie ograniczają możliwości oferowanych przez standard. Biblioteka oferuje również możliwość realizacji algorytów przetwarzających obrazy w~sposób potokowy. Taka realizacja ma zastosowanie wtedy, kiedy zachodzi potrzeba użycia kilku kerneli, dla których dane wejściowe kolejnego programu są danymi wyjściowymi poprzedniego. Implementacja  ogranicza liczbę operacji kopiowania danych pomiędzy pamięcią RAM komputera a~pamięcią wewnętrzną urządzenia, na którym wykonywany jest program poprzez zachowywanie cząstkowych obliczeń w~pamięci urządzenia.

Bibliotekę można podzielić na dwie części: część odpowiedzialną za kompilację kerneli oraz wszelkie powiązane z~tym kwestie oraz część odpowiedzialną za wykonywanie kerneli.
Ponieżej są przedstawione możliwości oraz szczegóły techniczne poszczególnych cześci.

\subsection{Kompilacja kerneli oraz obsługa urządzeń}
\label{subsec:kompilacjakerneli}
W~skład tej części wchodzi jedna klasa przedstawiona na rysunku \ref{fig:opencldevice}. Jest ona odpowiedzialna za pobieranie lisy dostępnych urządzeń, pobieranie podstawowych informacji o urządzeniu, tworzenie i~udostępnianie kontekstu oraz kolejki komend (fragmentów standardu OpenCL) oraz za kompilację kernela na dane urządzenie. Kontekst oraz kolejka komend są obiektami z API OpenCL za pomocą, których przeprowadzane jest wykonanie kodu na urządzeniu OpenCL.

Kod kernela może być podany jednej z~dwóch postaci: jako zmienna typu std::string, której zawartością jest kod lub jako zapisany w~osobnym pliku, który jest czytany i~przekazywany do funkcji wykonującej kompilację. Umożliwienie dwóch metod jest spowodowane różnymi ich właściwościami. Podczas tworzenia algorytmu bardziej przydatne jest używanie pliku, ponieważ łatwiej go edytować.  Wadą tego rozwiązania jest umieszczenie danego pliku w~odpowiednim miejscu w~systemie plików. Gdy praca nad kernelem jest zakończona wtedy można umieścić jego kod w~źródłach programu aby uniknąć problemów z~przenoszeniem aplikacji. Jest to operacja jednorazowa w~przypadku ostatecznej wersji kernela, więc nie istnieje problem edycji kodu.

\subsection{Wykonywanie kerneli}
\label{subsec:wykonywaniekerneli}
Zadaniem tej części jest ułatwienie użytkownikowi procesu kompilacji oraz wykonywania kerneli wraz z~przekazywaniem argumentów oraz pobieraniem wyników. Ten fragment biblioteki składa się z~wielu klas, których schemat jest przedstawiony na rys. \ref{fig:openclalgorithms}. Duża liczba klas jest spowodowana chęcią umożliwienia zastosowania biblioteki do wielu rodzajów kerneli. Prace nad biblioteką były skupione na realizacji algorytmów operujących na obrazach. Konieczność wprowadzenia dużego rozróżnienia wynika z~istnienia dużej liczby struktur wykorzystywanych w~standardzie do przekazywania parametrów wejściowych i wyjściowych oraz chęcią uściślenia zastosowania danego algorytmu.

Zastosowanie klas przedstawionych na rysunku \ref{fig:openclalgorutithms} umożliwia, w~optymalnych przypadkach, na minimalne zaangażowanie użytkownika biblioteki w~tworzenie kodu kontrolera i~skupienie się na konstrukcji kodu kernela. Koniecznymi do podania informacjami są: format obrazu danych wejściowych i~wyjściowych oraz kod kernela (zawarty w~pliku lub w~zmiennej). Dla bardziej zaawansowanych algorytmów, do działania których potrzebnych jest więcej argumentów wejściowych lub wyjściowych konieczne jest więcej pracy włożonych w~napisanie kodu kontrolera. Dla takich przypadków zrealizowano funkcje pomocnicze, które ułatwiają pracę.

\subsection{Tworzenie potoków kerneli}
\label{subsec:potokikerneli}

Potoki są często wykorzystywanym mechanizmem podczas przetwarzania danych, w~tym obrazów. Pozwalają na łączenie kilku mniejszcyh operacji w~jeden większy algorytm. Wiele z~tych mniejszych operacji jest używana w~większej liczbie algorytmów, dlatego pożądane jest, aby można było użyć raz napisanego kernela przy jak najmniejszym nakładzie pracy.

W~bibliotece zaimplementowano możliwość stworzenia w~prosty sposób potoku używającego jako danych wejściowych i~wyjściowych obrazów w~dwóch wymiarach. Klasy konieczne do realizacji potoku są przedstawione na rys \ref{dig:diagrampotok}. Zaimplementowane rozwiązanie posiada wady oraz zalety. Przy tradycyjnym podejściu wykonania kerneli konieczne jest każdorazowe kopiowanie danych z~i~do pamięci urządzenia. Użycie potoku pozwala na ograniczenie ilości kopiowanych danych. Zaimplementowano sposób wykonania kolejnych kerneli w~sposób sekwencyjny, pozwalający na bezpośrednie wykorzystanie wyników obliczeń jako argumentów wejściowych kolejnego kernela. Dodatkową zaletą jest możliwości wykorzystania kerneli stworzonych do potoku jako samodzielny algorytm przy małym nakładzie pracy oraz braku konieczności edycji kodu kernela. Istnieje możliwość zwrócenia przez ostatni proces potoku dodatkowej wartości, poza wynikowym obrazem. Wadą użycia potoku jest utrudniona możliwość zwrócenia dodatkowych danych przez kernele, które nie są ostatnimi w~potoku.

\subsection{Reguły dotyczące kerneli}
\label{subsec:regulykerneli}

Każdy kernel, który ma być użyty z~zastosowaniem bblioteki musi spełniać klika zasad. Najważniejszą jest kolejność argumentów. Zawsze pierwszym argumentem są dane wejściowie a drugim dane wyjściowe. Obecnie wspierane są argumenty: wektor, obraz 2D lub obraz 3D (tylko jako argument wejściowy). Kolejnymi argumentami mogą być inne dane. Mogą to być parametry pomocnicze, jeśli są konieczne do wykonania obliczeń lub kolejne wyniki, jeśli rezultatem danego algorytmu jest więcej niż jeden obraz lub wektor.

\subsection{Obsługa błędów}
\label{subsec:obslugabledow}

Biblioteka przekazuje błędy występujące podczas wyoływania API OpenCL do użytkownika za pomocą wyjątków, które są usystematyzowane. Hierarchia wyjątków jest przedstawiona na rysunku \ref{fig:diagramwyjatkow}. Większość zwracanych błędów występuje przy wywołaniach funkcji OpenCL. Z~tego powodu do opisu błędu z~punktu widzenia biblioteki dodawana jest informacja o~kodzie błędu, który wystąpił podczas wywołania funkcji standardu. Zwracany kod jest w~postaci opisowej, dlatego wraz z~dokumentacją OpenCL pozwala na szybkie rozpoznanie błędu.

\subsection{Zaimplementowane algorytmy}
\label{subsec:algorytmy}

W~ramach biblioteki zaimplementowano algorytmy wykorzystywane w pracy. Są to: filtr Bayera, obliczanie konwolucji obrazu z maską, algorytmy służące rozpoznawaniu przedstawione w rodziale \ref{cos:cos}.