\chapter{OpenCL}
\label{cha:opencl}

W~tym rodziale przedstawiono sposób implementacji algorytmów z~użyciem standardu OpenCL oraz stworzoną bibliotekę służącą ułatwieniu pracy. Zdecydowano się na realizację danej biblioteki z~uwagi na to, że w~cześci programu, która kontroluje wykonanie kodu na karcie graficznej (nazywanego kernelami) wiele czynności jest powtarzanych przy implementacji każdego algorytmu. Zatem zadaniem biblioteki jest ułatwienie implementacji kontrolera nie ograniczając możliwości oferowanych przez standard OpenCL oraz umożliwienie łatwiego rozszerzania dostępnych funkji.

\section{Implementacja algorytmów z~użyciem OpenCL}  
\label{sec:szczegolyOpenCL}

W celu implementacji algorytmów z~użyciem standardu OpenCL konieczne jest napisanie dwóch oddzielnych części. Pierwszą jest kod algorytmu zapisany w~języku stworzonym w ramach standardu OpenCL, drugą jest kod wykonywany na procesorze ogólnego przeznaczania wykorzystujący API, które jest zdefiniowane w języku C.

Algorytmy implementowane są w~postaci funkcji, które są nazywane kernelami. Są one napisane w~języku stworzonym przez twórców standardu. Bazuje on na języku ISO C99 i~zawiera jego podzbiór wraz z~rozszerzeniami służacymi implementacji algorytmów w sposób równoległy, ułatwiającymi obsługę wektorów, macierzy oraz obrazów. Kompilacja kodu napisanego w~tym języku odbywa się w~trakcie działania programu kontrolera, ponieważ sposób kompilacji jest zależny od posiadanego urządzenia, na którym będzie wykonywany kod. Jest to spowodowane tym, że kod języka OpenCL jest kompilowany zależnie od platformy, na której jest uruchamiany. Może to powodować problemy z~przenoszalnością pomiędzy różnymi urządzeniami w~przypadku, gdy używane są rozszerzenia OpenCL. W~celu uniknięcia problemów należy stosować konstrukcje języka, które są częścią podstawowej wersji standardu. Ta część jest wystarczająca do większości algorytmów.

Zadania kodu kontrolera można podzielić na dwa fragmenty. Pierwszym, jest inicjalizacja, podczas której jest dokonywany wybór urządzenia docelowaego oraz kompilacja kerneli. Proces wyboru urządzenia może być bardziej skomplikony w przypadku, gdy w~systemie jest dostępnych więcej niż jedna platforma OpenCL. Przykładem takiej sytuacji jest posiadanie dwóch kart graficznych w~jednym komputerze. W~zależności od parametrów urządzeniem może być porządane użycie jednej, lepszej karty lub obu. OpenCL pozwala na wykorzystanie obu rozwiązań. Dzięki temu, że kod kerneli może być wykonywany asynchronicznie można przeprowadzać obliczenia jednocześnie na wielu urządzeniach. Po wyborze platformy docelowej należy skompilować kernel. Dopisać o kompilacji!!!!!!!!!!!!!

Drugim fragmentem kodu kontrolera jest przekazywanie parametrów, wykonywanie kerneli oraz pobieranie wyników. Te czynności są realizwane przy każdym nowy algorytmie.

\section{Zrealizowana biblioteka}  
\label{sec:biblioteka}

Biblioteka zastała zaimplementowana w języku C++. Wybrano ten język ponieważ jego integracja z~API OpenCL napisanym w języku C jest ?prosta?. Biblioteka została zrealizowana w~sposób obiektowy oraz z~użyciem wyjątków ułatwiających pracę. Więcej szczegółów dotyczącyh wyjątków jest przedstawiona w~sekcji \ref{subsec:obslugabledow}. Obietkowość zapewnia maksymalne ograniczenie redundancji napisanego kodu odpowiedzialnego za kompilację, przekazywanie argumentów, wykonywanie kernel oraz pobieranie wyników. Aby to umożliwić należy opracować zbiór reguł, których należy przestrzegać podczas pisania kerneli. Są one opisane w sekcji \ref{subsec:regulykerneli}. Reguły te nie ograniczają możliwości oferowanych przez standard. Biblioteka oferuje również możliwość realizacji algorytów w sposób potokowy. Taka realizacja ma zastosowanie wtedy, kiedy zachodzi potrzeba użycia kilku kerneli, dla których dane wejściowe kolejnego programu są danymi wyjściowymi poprzedniego. Implementacja  ogranicza liczbę operacji kopiowania danych pomiędzy pamięcią RAM komputera a~pamięcią wewnętrzną urządzenia, na którym wykonywany jest program poprzez zachowywanie cząstkowych obliczeń w~pamięci urządzenia?.

Bibliotekę można podzielić na dwie części: część odpowiedzialną za kompilację kerneli oraz wszelkie powiązane z~tym kwestie oraz część odpowiedzialną za wykonywanie kerneli.
Ponieżej są przedstawione możliwości oraz szczegóły techniczne poszczególnych cześci.

\subsection{Kompilacja kerneli oraz obsługa urządzeń}
\label{subsec:kompilacjakerneli}
W~skład tej części wchodzi jedna klasa przedstawiona na rysunku \ref{fig:opencldevice}. Jest ona odpowiedzialna za pobieranie lisy dostępnych urządzeń, pobieranie podstawowych informacji o urządzeniu, tworzenie i~udostępnianie kontekstu oraz kolejki komend (fragmentu standardu OpenCL) oraz za kompilację kernela na dane urządzenie. Kod kernela[synonim] może być podany jednej z~dwóch postaci: jako string lub zapisany w~osobnym pliku. Podczas tworzenia algorytmu bardziej przydatne jest używanie pliku, ponieważ łatwiej go edytować. Gdy praca nad kernelem jest zakończona wtedy można umieścić jego kod w~źródłach programu, aby uniknąć problemów z~przenoszeniem aplikacji.

\subsection{Wykonywanie kerneli}
\label{subsec:wykonywaniekerneli}
Zadaniem tej części jest ułatwienie użytkownikowi procesu kompilacji oraz wykonywania kerneli wraz z~przekazywaniem argumentów oraz pobieraniem wyników. Ten fragment biblioteki składa się z~wielu klas. Jest to spowodowane chęcią umożliwienia zastosowania biblioteki do wielu rodzajów kerneli. Konieczność wprowadzenia dużego rozróżnienia wynika z~istnienia dużej liczby struktur wykorzystywanych w~standardzie do przekazywania parametrów wejściowych i wyjściowych.



\subsection{Tworzenie potoków kerneli}
\label{subsec:potokikerneli}

Potoki są często wykorzystywanym mechanizmem podczas przetwarzaniu obrazów. Pozwalają na łączenie kilku mniejszcyh operacji w~jeden większy algorytm. Wiele z~tych mniejszych operacji jest używana do większej liczby algorytmów, dlatego cennym jest, aby można było użyć raz napisanego kernela. Przy tradycyjnym podejściu wykonania kerneli konieczne jest każdorazowe kopiowanie danych z~i~do pamięcie urządzenia. W~bibliotece zaimplementowano sposób wykonania kolejnych kerneli w~sposób sekwencyjny, pozwalający na bezpośrednie wykorzystanie wyników obliczeń jako argumentów wejściowych kolejnego kernela. Dodatkową zaletą jest to, że jeden kernel może być wykorzystywany zarówno w~obliczeniach z zastosowaniem potoku, jak również może być wykonywany osobno.



\subsection{Reguły dotyczące kerneli}
\label{subsec:regulykerneli}

Każdy kernel, który ma być użyty z~zastosowaniem bblioteki musi spełniać klika zasad. Najważniejszą jest kolejność argumentów. Zawsze pierwszym argumentem są dane wejściowie a drugim dane wyjściowe. Obecnie wspierane są argumenty: wektor, obraz 2D lub obraz 3D. Kolejnymi argumentami są dane pomocnicze, jeśli są konieczne do wykonania obliczeń.

\subsection{Obsługa błędów}
\label{subsec:obslugabledow}

Biblioteka przekazuje błędy występujące podczas wyoływania API OpenCL do użytkownika za pomocą wyjątków, które są usystematyzowane. Hierarchia wyjątków jest przedstawiona na rysunku \ref{fig:diagramwyjatkow}.

\subsection{Zaimplementowane algorytmy}
\label{subsec:algorytmy}

W~ramach biblioteki zaimplementowano algorytmy wykorzystywane w pracy. Są to: filtr Bayera, obliczanie konwolucji obrazu z maską, algorytmy służące rozpoznawaniu przedstawione w rodziale \ref{cos:cos}.