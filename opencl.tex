\chapter{OpenCL}
\label{cha:opencl}

W~niniejszym rozdziale przedstawiono sposób implementacji algorytmów z~użyciem standardu OpenCL oraz stworzoną bibliotekę służącą ograniczeniu liczby błędów oraz przyśpieszeniu pracy poprzez uniknięcie powtarzania kodu. Zdecydowano się na realizację danej biblioteki z~uwagi na to, że w~części programu, która kontroluje wykonanie kodu na karcie graficznej (nazywanego kernelami) wiele czynności jest powtarzanych przy implementacji każdego algorytmu. Zatem zadaniem biblioteki jest ułatwienie implementacji kontrolera nie ograniczając możliwości oferowanych przez standard OpenCL oraz umożliwienie łatwego rozszerzania dostępnych funkcji. Biblioteka była tworzona oraz testowana dla wersji 1.1 standardu OpenCL.

\section{Implementacja algorytmów z~użyciem OpenCL}  
\label{sec:szczegolyOpenCL}

W celu implementacji algorytmów z~użyciem standardu OpenCL konieczne jest napisanie dwóch oddzielnych części. Pierwszą jest kod algorytmu zapisany w~języku stworzonym w ramach standardu OpenCL, drugą jest kod wykonywany na procesorze ogólnego przeznaczania wykorzystujący API, które jest zdefiniowane w języku C.

Algorytmy implementowane są w~postaci funkcji, które są nazywane kernelami. Są one napisane w~języku stworzonym przez twórców standardu OpenCL. Bazuje on na języku ISO C99 i~zawiera jego podzbiór wraz z~rozszerzeniami służącymi implementacji algorytmów w sposób równoległy, ułatwiającymi obsługę wektorów, macierzy oraz obrazów. Maksymalna wielkość obrazów, osobno dla obrazów 2D i 3D, jest określona dla konkretnego urządzenia. Kompilacja kodu napisanego w~tym języku odbywa się w~trakcie działania programu kontrolera, ponieważ sposób kompilacji jest zależny od posiadanego urządzenia, na którym będzie wykonywany kod. Jest to spowodowane tym, że kod języka OpenCL jest kompilowany zależnie od platformy, na której jest uruchamiany. Może to powodować problemy z~przenoszalnością pomiędzy różnymi urządzeniami w~przypadku, gdy używane są rozszerzenia OpenCL. W~celu uniknięcia problemów należy stosować konstrukcje języka, które są częścią podstawowej wersji standardu. Ta część jest wystarczająca do większości algorytmów.

Zadania kodu kontrolera można podzielić na dwa typy. Pierwszym, jest inicjalizacja, podczas której jest dokonywany wybór urządzenia docelowego, kompilacja kerneli oraz przygotowanie do wykonania. Proces wyboru urządzenia może być bardziej skomplikowany w przypadku, gdy w~systemie jest dostępnych więcej niż jedna platforma OpenCL. Przykładem takiej sytuacji jest posiadanie dwóch kart graficznych w~jednym komputerze. W~zależności od parametrów urządzeniem może być pożądane użycie jednej, lepszej karty lub obu. OpenCL pozwala na wykorzystanie obu rozwiązań. Dzięki temu, że kod kerneli może być wykonywany asynchronicznie można przeprowadzać obliczenia jednocześnie na wielu urządzeniach. Po wyborze platformy docelowej należy skompilować kernel, który należy następnie przygotować do wykonania. W~tym celu należy utworzyć obiekty, które będą parametrami kernela. Mogą to być wektory danych lub obrazy. Po stworzeniu tych obiektów, należy przypisać je do argumentów kernela, zgodnie z~deklaracją w~kodzie.

Drugim fragmentem kodu kontrolera jest przekazywanie parametrów, wykonywanie kerneli oraz pobieranie wyników. Te czynności są realizowane przy wykonaniu każdego algorytmu. Dane, z~których korzysta kernel są kopiowane pomiędzy pamięcią urządzenia a~pamięcią RAM komputera, na którym jest wykonywany kontroler. Każdą z~tych operacji można wykonać synchroniczne lub asynchronicznie. Przy wykonaniu asynchronicznym jest możliwość, aby zarejestrować funkcję zwrotną lub poczekać na zakończenie wykonania.

\section{Zrealizowana biblioteka}  
\label{sec:biblioteka}

Biblioteka zastała zaimplementowana w języku C++. Wybrano ten język ponieważ jego integracja z~API OpenCL napisanym w języku C jest prosta. Biblioteka została zrealizowana w~sposób obiektowy oraz z~użyciem wyjątków ułatwiających obsługę sytuacji krytycznych. Więcej szczegółów dotyczących wyjątków przedstawiono w~sekcji \ref{subsec:obslugabledow}. Obiektowość pozwala na ograniczenie redundancji napisanego kodu odpowiedzialnego za kompilację, przekazywanie argumentów, wykonywanie kernel oraz pobieranie wyników. Aby to umożliwić należy opracować zbiór reguł, których należy przestrzegać podczas pisania kerneli. Są one opisane w sekcji \ref{subsec:regulykerneli}. Reguły te nie ograniczają możliwości oferowanych przez standard. Biblioteka oferuje również możliwość realizacji algorytmów przetwarzających obrazy w~sposób potokowy. Taka realizacja ma zastosowanie wtedy, kiedy zachodzi potrzeba użycia kilku kerneli, dla których dane wejściowe kolejnego programu są danymi wyjściowymi poprzedniego. Implementacja  ogranicza liczbę operacji kopiowania danych pomiędzy pamięcią RAM komputera a~pamięcią wewnętrzną urządzenia, na którym wykonywany jest program poprzez zachowywanie cząstkowych obliczeń w~pamięci urządzenia.

W bibliotece można wyróżnić dwie części: część odpowiedzialną za kompilację kerneli i~wszelkie powiązane z~tym kwestie oraz część odpowiedzialną za wykonywanie kerneli.
Poniżej są przedstawione możliwości oraz szczegóły techniczne poszczególnych części.

\subsection{Kompilacja kerneli oraz obsługa urządzeń}
\label{subsec:kompilacjakerneli}
Funkcjonalność ta jest realizowana przez jedną klasę przedstawioną na rysunku \ref{fig:opencldevice}. Jest ona odpowiedzialna za pobieranie lisy dostępnych urządzeń, pobieranie podstawowych informacji o urządzeniach, tworzenie i~udostępnianie kontekstu oraz kolejki komend (fragmentów standardu OpenCL) oraz za kompilację kerneli na konkretne urządzenie. Kontekst oraz kolejka komend są obiektami z API OpenCL za pomocą, których przeprowadzane jest wykonanie kodu na urządzeniu OpenCL.

Kod kernela może być podany w~jednej z~dwóch postaci: jako zmienna typu std::string, której zawartością jest kod lub jako zapisany w~osobnym pliku, który jest czytany i~przekazywany do funkcji wykonującej kompilację. Umożliwienie dwóch metod jest spowodowane różnymi ich właściwościami. Podczas tworzenia algorytmu bardziej przydatne jest używanie pliku, ponieważ łatwiej go edytować.  Wadą tego rozwiązania jest umieszczenie danego pliku w~odpowiednim miejscu w~systemie plików. Gdy praca nad kernelem jest zakończona wtedy można umieścić jego kod w~źródłach programu aby uniknąć problemów z~przenoszeniem aplikacji. Jest to operacja jednorazowa w~przypadku ostatecznej wersji kernela, więc nie istnieje problem edycji kodu.

\subsection{Wykonywanie kerneli}
\label{subsec:wykonywaniekerneli}
Funkcjonalność ta ułatwia użytkownikowi proces kompilacji oraz wykonywania kerneli wraz z~przekazywaniem argumentów oraz pobieraniem wyników. Ten fragment biblioteki składa się z~wielu klas, których schemat jest przedstawiony na rys. \ref{fig:openclalgorithms}. Duża liczba klas jest spowodowana potrzebą umożliwienia zastosowania biblioteki do wielu rodzajów kerneli. Prace nad biblioteką były skupione na realizacji algorytmów operujących na obrazach. Konieczność wprowadzenia dużego rozróżnienia wynika z dużej liczby struktur wykorzystywanych w~standardzie do przekazywania parametrów wejściowych i wyjściowych oraz chęcią uściślenia zastosowania danego algorytmu.

Zastosowanie klas przedstawionych na rysunku \ref{fig:openclalgorutithms} umożliwia, w~optymalnych przypadkach, na minimalne zaangażowanie użytkownika biblioteki w~tworzenie kodu kontrolera i~skupienie się na konstrukcji kodu kernela. Koniecznymi do podania informacjami są: format obrazu danych wejściowych i~wyjściowych oraz kod kernela (zawarty w~pliku lub w~łańcuchu znakowym). Dla bardziej zaawansowanych algorytmów, do działania których potrzebnych jest więcej argumentów wejściowych lub danych rezultatów konieczne jest więcej pracy włożonej w~napisanie kodu kontrolera. Dla takich przypadków zrealizowano funkcje pomocnicze.

\subsection{Tworzenie potoków kerneli}
\label{subsec:potokikerneli}

Mechanizmem często wykorzystywanym podczas przetwarzania danych, w~tym obrazów są potoki. Pozwalają na łączenie kilku mniejszych operacji w~jeden większy algorytm. Wiele z~tych mniejszych operacji jest używana w~większej liczbie algorytmów, dlatego pożądane jest, aby umożliwić wielokrotne użycie raz napisanego kernela przy jak najmniejszym nakładzie pracy.

W~bibliotece zaimplementowano możliwość stworzenia w~prosty sposób potoku używającego jako danych wejściowych i~wyjściowych obrazów w~dwóch wymiarach. Klasy konieczne do realizacji potoku są przedstawione na rys \ref{fig:diagrampotok}. Zaimplementowane rozwiązanie posiada wady oraz zalety. Przy tradycyjnym podejściu wykonania kerneli konieczne jest każdorazowe kopiowanie danych z~i~do pamięci urządzenia. Użycie potoku pozwala na ograniczenie ilości kopiowanych danych. Zaimplementowano sposób wykonania kolejnych kerneli w~sposób sekwencyjny, pozwalający na bezpośrednie wykorzystanie wyników obliczeń jako argumentów wejściowych kolejnego kernela. Dodatkową zaletą jest możliwości wykorzystania kerneli stworzonych do potoku jako samodzielny algorytm przy małym nakładzie pracy oraz braku konieczności edycji kodu kernela. Istnieje możliwość zwrócenia przez ostatni kernel potoku dodatkowej wartości, poza wynikowym obrazem. Wadą użycia potoku jest utrudniona możliwość zwrócenia dodatkowych danych przez kernele, które nie są ostatnimi w~potoku.

\subsection{Reguły dotyczące kerneli}
\label{subsec:regulykerneli}

Każdy kernel, który ma być użyty z~zastosowaniem biblioteki musi spełniać klika warunków. Najważniejszą jest kolejność argumentów. Zawsze pierwszym argumentem są dane wejściowe a drugim struktura, do której są zapisywane wyniki. Obecnie wspierane są następujące typy argumentów:
\begin{itemize}
\item wektor,
\item obraz 2D,
\item obraz 3D (tylko jako argument wejściowy).
\end{itemize}
Kolejnymi argumentami mogą być inne dane. Mogą to być parametry pomocnicze, jeśli są konieczne do wykonania obliczeń lub kolejne wyniki, jeśli rezultatem danego algorytmu jest więcej niż jeden obraz lub wektor.

\subsection{Obsługa błędów}
\label{subsec:obslugabledow}

Biblioteka przekazuje błędy występujące podczas wywoływania API OpenCL do użytkownika za pomocą wyjątków, które są usystematyzowane. Hierarchia wyjątków jest przedstawiona na rysunku \ref{fig:diagramwyjatkow}. Większość zwracanych błędów występuje przy wywołaniach funkcji OpenCL. Z~tego powodu do opisu błędu z~punktu widzenia biblioteki dodawana jest informacja o~kodzie błędu, który wystąpił podczas wywołania funkcji standardu. Zwracany kod jest w~postaci zgodnej z dokumentacją, dlatego pozwala na szybkie rozpoznanie przyczyny błędu.

\subsection{Zaimplementowane algorytmy}
\label{subsec:algorytmy}

W~ramach biblioteki zaimplementowano algorytmy wykorzystywane w pracy. Są to: filtr Bayera, obliczanie konwolucji obrazu z maską, algorytmy służące rozpoznawaniu przedstawione w rozdziale \ref{subsubsec:rozpoznawaniePlam}.